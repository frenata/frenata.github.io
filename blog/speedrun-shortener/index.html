<!DOCTYPE html>
<html>

<head>
  <title> Speedrun: URL Shortener &middot; Kata Frenata </title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="generator" content="Hugo 0.18-DEV" />


<link rel="stylesheet" href="http://frenata.me/css/vec.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
<link rel="shortcut icon" href="/favicon.ico">


<link href="" rel="alternate" type="application/rss+xml" title="Kata Frenata" />

</head>

<body>
  <header>
  <nav>
    <ul>
      
      
      <li class="pull-left ">
        <a href="http://frenata.me">/home/frenata</a>
      </li>
      
      
      <li class="pull-left current">
        <a href="/blog">~/blog</a>
      </li>
      
      
      <li class="pull-left ">
        <a href="/cv">~/cv</a>
      </li>
      
      
      <li class="pull-left ">
        <a href="/site">~/site</a>
      </li>
      
  
      <li class="pull-right"><a href=""><i class="fa fa-rss"></i></a></li>
    </ul>
  </nav>
</header>

  <div class="content">
    
    
    <section class="post">
      <h1 class="post-title"><a href="http://frenata.me/blog/speedrun-shortener/">Speedrun: URL Shortener</a></h1>
      <span class="post-date">May 4, 2017 </span>
      <div class="post-content">
        

<h3 id="fresh-links">Fresh Links</h3>

<ul>
<li><a href="https://api.frenata.net/tiny/">Deployed App</a></li>
<li><a href="https://github.com/frenata/api-frenata/tree/master/src/tiny">GitHub repo</a></li>
</ul>

<h3 id="one-repo-to-rule-them-all">One Repo to Rule Them All</h3>

<p>I spent a good deal of time before/during/after writing the URL shortener itself on infrastructure, so it seems reasonable to discuss it here. Working with subtrees and orphaned branches was a bit annoying on my previous speedrun attempts, and since the <em>final</em> objective was to unite all the projects together anyway&hellip;</p>

<p>I decided to do it early.</p>

<p>First, I got my heroku account verified and my own domain name pointing to one of my projects there.</p>

<p>Then I set up a new git repo, and merged the previous two orphaned branches into it.</p>

<p>Then I reorganized my existing code into packages, a <code>main</code> package with that distributed routes to other packages, each of which would handle its own microservice. Here&rsquo;s what my new main function looks like:</p>

<pre><code>func main() {
	// get bound port of host system
	port := os.Getenv(&quot;PORT&quot;)

	http.HandleFunc(&quot;/&quot;, index)
	http.HandleFunc(timestamp.ROUTE, timestamp.Handler)
	http.HandleFunc(headers.ROUTE, headers.Handler)
	http.HandleFunc(tiny.ROUTE, tiny.Handler)
	log.Fatal(http.ListenAndServe(&quot;:&quot;+port, nil))
}
</code></pre>

<p>Simple and sweet, all the logic internal to the services is contained in those services, including the routes they should be served on!</p>

<h3 id="persistence-pays">Persistence Pays</h3>

<p>I knew that a critical question was data persistence, and I also knew that I wanted to do this with a minimum of fuss, as befits a &ldquo;speed run,&rdquo; so I decided not to skip using a database&hellip;</p>

<p>But since heroku pulls things down after inactivity on the free tier, I needed at least some kind of persistence, or the generated short addresses would likely only last as long as a dyno was active. So I decided to do the simplest possible thing, and just write to a file. This would almost certainly be a <em>terrible</em> idea in any kind of production server due to a variety of threading issues, but I determined that it was acceptable for what I viewed as a proof of concept.</p>

<p>For doing this write I used the following function:</p>

<pre><code>func writeDB(sr ShortenerResponse) {
	f, err := os.OpenFile(DB, os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0600)
	if err != nil {
		panic(err)
	}
	defer f.Close()

	data, _ := json.Marshal(sr)
	if _, err = f.Write(append(data, '\n')); err != nil {
		panic(err)
	}
}
</code></pre>

<p>In short, this opens a file in &ldquo;append&rdquo; mode, creating it if it doesn&rsquo;t already exist, and writes a JSON object to the file, being sure to close this file before the function ends (the purpose of <code>defer f.Close()</code>).</p>

<p>Another function <code>init</code>, which in go runs only when the package is first loaded, reads from this same file (if it exists) and loads the contents into memory.</p>

<h3 id="map-the-world">Map the World!</h3>

<p>The objects themselves were built from a now familiar go <code>struct</code> with JSON tags:</p>

<pre><code>type ShortenerResponse struct {
	Original *string `json:&quot;original_url&quot;`
	Short    *string `json:&quot;short_url&quot;`
}
</code></pre>

<p>This data structure is essentially only used when marshaling to JSON for the response to a client, or for unmarshalling the contents of my &ldquo;database file&rdquo;.</p>

<p>For actually doing the work of redirect on demand, I used a map, that takes <code>string</code>s and translates them directly into other <code>string</code>s. In short: a requested short URL redirects to the long URL without bothering to iterate over anything.</p>

<h3 id="what-happens">What Happens?</h3>

<ol>
<li>a request is routed to the handler function</li>
<li>the handler checks the map of URLs, and if a match is found, it just redirects to the long URL</li>
<li>or it calls <code>Shorten</code> with the URL</li>
<li>this function verifies that the URL is valid and sends an error response if it is not</li>
<li>or it calls <code>NewResponse</code> which builds a response, adds an entry in the map, and returns the Response to <code>Shorten</code>&hellip;</li>
<li>which writes the new Response to the DB&hellip;</li>
<li>and returns the JSON representation of it to the handler&hellip;</li>
<li>which returns it to the user.</li>
</ol>

<h3 id="room-for-improvement">Room for Improvement</h3>

<ul>
<li>use a proper database, even just SQLite, instead of a flat file</li>
<li>use a better hashing function from long URLs to short URLs, and check for collisions</li>
<li>do something to better accomodate thread/process scaling, probably running a separate goroutine to issue writes to the DB/map, using channels</li>
</ul>

      </div>
    </section>
    
    <section class="pagination clearfix">
      
      <a class="btn previous " href="http://frenata.me/blog/recurse/"> Recurse Center: Accepted </a> 
       
      
      <a class="btn next " href="http://frenata.me/blog/speedrun-images/"> Speedrun: Image Search </a> 
      
    </section>
    
    
  </div>
  
  <footer>
  <div class="footer-info">
    <p>
      <a href="mailto:andrew@frenata.net?subject="><i class="fa fa-envelope-o"></i> andrew@frenata.net </a>
      {
        <a href="https://gohugo.io/" title="Hugo :: A fast and modern static website engine">Hugo 0.18-DEV</a>,
        <a href="https://github.com/IvanChou/yii.im" title="vec">Vec</a> 
      }
      {<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/" title="CC BY-NC-ND 3.0">CC BY-NC-ND 3.0</a>}
    </p>
  </div>
</footer>
  
  <script src="http://frenata.me/js/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
  </script>
  

</body>

</html>
