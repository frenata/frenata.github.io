<!DOCTYPE html>
<html>

<head>
  <title> Android Architecture, Part 3 &middot; Kata Frenata </title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="generator" content="Hugo 0.18-DEV" />


<link rel="stylesheet" href="http://frenata.me/css/vec.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
<link rel="shortcut icon" href="/favicon.ico">


<link href="" rel="alternate" type="application/rss+xml" title="Kata Frenata" />

</head>

<body>
  <header>
  <nav>
    <ul>
      
      
      <li class="pull-left ">
        <a href="http://frenata.me">/home/frenata</a>
      </li>
      
      
      <li class="pull-left current">
        <a href="/blog">~/blog</a>
      </li>
      
      
      <li class="pull-left ">
        <a href="/site">~/site</a>
      </li>
      
  
      <li class="pull-right"><a href=""><i class="fa fa-rss"></i></a></li>
    </ul>
  </nav>
</header>

  <div class="content">
    
    
    <section class="post">
      <h1 class="post-title"><a href="http://frenata.me/blog/android-architecture-3/">Android Architecture, Part 3</a></h1>
      <span class="post-date">Apr 20, 2017 </span>
      <div class="post-content">
        

<h3 id="previously">Previously</h3>

<p>After implementing a <a href="../android-architecture-1">class hierarchy</a> and a unified point of database access via a <a href="../android-architecture-2">Content Provider</a> the core mechanisms of my app were in place: the ability to do basic CRUD (Create, Retrieve, Update, Delete) actions on the various types in my database. It was time to put the finishing touches, not all of which were trivial.</p>

<h3 id="time-keeps-ticking">Time Keeps Ticking&hellip;</h3>

<p>The first major task was to enable the user to create notifications for the various data types, most of which had date fields attached. However, in order to get the database functionality working, I had skipped any attempt at verifying user entered dates, which were stored in the SQLite database as plain strings. While a well intentioned user would no doubt enter real dates instead of <code>&quot;next week&quot;</code>, it didn&rsquo;t seem right to cause notifications to fail for incorrectly written dates, either silently or explicitly.</p>

<p>Related was the question of the order of items on the lists of terms/courses/assessments. Keeping with &ldquo;getting it done&rdquo; I had sorted them simply by the name of the entry, knowing I would eventually want to &ldquo;do it right&rdquo;. That <em>time</em> was of course now.</p>

<p>First I enforced that user entered dates be in a specific format, <code>23 April 2017</code>. But while simple to enter by text and obvious to read, this type of data is not easily sortable. I needed to translate dates into something more like a timestamp for storage in the SQLite database. Thus was a class born <code>DateFormatter</code>, which contained several static helper methods to translate dates from my chosen human readable format, to a timestamp, and back again. I would also add methods to translate dates into Unix epoch timestamps, since this is how I would schedule notifications.</p>

<h3 id="notify-me">Notify Me</h3>

<p>Actually getting notifications working wasn&rsquo;t entirely trivial either, but not from a coding standpoint. This was the first time I ran into the stumbling block of the Internet: host to information about many different ways of working with Android apps, all from different APIs and few marked clearly.</p>

<p>I pressed on, found a strategy that worked and implemented it. Testing it consisted of forcing the menu items to schedule notifications not on the date specified, but some fixed amount of time, say 5 seconds, after <code>SystemClock.elapsedRealtime()</code>.</p>

<h3 id="worth-a-thousand-sloc">Worth a Thousand SLOC</h3>

<p>Next up was attaching camera photos to notes. I had kept putting this off because it felt like it would be complicated, but truly Android makes the simple things complicated and the complicated things simple. The actual code to call out to the camera to take a picture?</p>

<pre><code>public void takePicture(View view) {
	Intent takePictureIntent = 
		new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
	if (takePictureIntent.resolveActivity(
				getPackageManager()) != null) {
		startActivityForResult(
				takePictureIntent, 
				REQUEST_IMAGE_CAPTURE);
	}
}
</code></pre>

<p>Taking the image and forcing it into and out of the database was somewhat more involved, but not very. SQL has a datatype <code>blob</code> for a reason. (Though <em>better</em> practice would probably have been to save a URI for the photo)</p>

<p>SMS was scarely more complicated:</p>

<pre><code>private void sendSMS() {
	Uri uri = Uri.parse(&quot;content://contacts&quot;);
	Intent intent = new Intent(Intent.ACTION_PICK, uri);
	intent.setType(
			ContactsContract.
			CommonDataKinds.
			Phone.CONTENT_TYPE);
	startActivityForResult(intent, 1);
}
</code></pre>

<h3 id="minor-minor-minor">Minor Minor Minor</h3>

<p>There were a few other minor details to fulfill various requirements or my own sense of pride:</p>

<ul>
<li>finding something semi-reasonable to store not in the SQLite database, but with SharedPrefs</li>
<li>making sure that somewhere I was using an <code>ArrayList</code></li>
<li>fixing a nagging <code>InternalException</code> that had not disrupted anything but been hitting the logs since the beginning of the project</li>
<li>validating deletion of database items to prevent orphaned data</li>
<li>adding a wider selection of sample data</li>
<li>icons</li>
<li>reducing some layout duplication</li>
<li>refactoring the massive amount of duplicated code in the <code>ContentProvider</code></li>
</ul>

<h3 id="wrapping-it-up-in-an-apk">Wrapping it up in an APK</h3>

<p>Ultimately I learned a lot, including that working with XML is not my idea of fun and that mobile app development might not be either. You can certainly develop something rapidly if you know what you&rsquo;re doing, but boilerplate is everywhere. Android Studio seems almost a necessity, just to keep track of the massive Android library. Discerning which information is from too far in the past to be of use, which information is for an API too far in the future to be of use, and which information is just right is a massive pain.</p>

<p>Making it all look good is certainly not as easy as it looks. It may be some time before I revisit Android development, but I&rsquo;m glad I was pushed to do it.</p>

      </div>
    </section>
    
    <section class="pagination clearfix">
      
      <a class="btn previous " href="http://frenata.me/blog/android-architecture-2/"> Android Architecture, Part 2 </a> 
       
      
      <a class="btn next " href="http://frenata.me/blog/speedrun-timestamp/"> Speedrun: Timestamp Microservice in Go </a> 
      
    </section>
    
    
  </div>
  
  <footer>
  <div class="footer-info">
    <p>
      <a href="mailto:andrew@frenata.net?subject="><i class="fa fa-envelope-o"></i> andrew@frenata.net </a>
      {
        <a href="https://gohugo.io/" title="Hugo :: A fast and modern static website engine">Hugo 0.18-DEV</a>,
        <a href="https://github.com/IvanChou/yii.im" title="vec">Vec</a> 
      }
      {<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/" title="CC BY-NC-ND 3.0">CC BY-NC-ND 3.0</a>}
    </p>
  </div>
</footer>
  
  <script src="http://frenata.me/js/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
  </script>
  

</body>

</html>
